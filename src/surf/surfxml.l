/* Validating XML processor for surfxml.dtd.
 * Generated 2005/01/04 14:37:23.
 *
 * This program was generated with the FleXML XML processor generator,
 * (Id: flexml.pl,v 1.29 2005/01/04 09:30:15 alegrand Exp).
 * Copyright © 1999 Kristoffer Rose.  All rights reserved.
 *
 * You can redistribute and/or modify this program provided the following
 * two conditions hold:
 *
 * 1. The program is distributed WITHOUT ANY WARRANTY from the author of
 *    FleXML; without even the implied warranty of MERCHANTABILITY or
 *    FITNESS FOR A PARTICULAR PURPOSE.
 *
 * 2. The program distribution conditions do not in any way affect the
 *    distribution conditions of the FleXML system used to generate this
 *    file or any version of FleXML derived from that system.
 *
 * Notice that these are explicit rights granted to you for files
 * generated by the FleXML system.  For your rights in connection with
 * the FleXML system itself please consult the GNU General Public License.
 */

%{

/* Version strings. */
const char rcs_flexml_skeleton[] =
 "$" "Id: skel,v 1.16 1999/12/09 04:01:51 krisrose Exp $";
const char rcs_flexml[] =
 "$" "Id: flexml.pl,v 1.29 2005/01/04 09:30:15 alegrand Exp $";

/* ANSI headers. */
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <stdarg.h>
#include <ctype.h>

/* Generated definitions. */
#define FLEXML_BUFFERSTACKSIZE 10000000

/* XML processor api. */
#include "surf/surfxml.h"

/* FleXML-provided data. */
const char* pcdata;
AT_network_link_bandwidth A_network_link_bandwidth;
AT_cpu_name A_cpu_name;
AT_network_link_state A_network_link_state;
AT_argument_value A_argument_value;
AT_cpu_availability_file A_cpu_availability_file;
AT_process_host A_process_host;
AT_route_src A_route_src;
AT_network_link_latency_file A_network_link_latency_file;
AT_cpu_availability A_cpu_availability;
AT_network_link_name A_network_link_name;
AT_route_element_name A_route_element_name;
AT_cpu_power A_cpu_power;
AT_process_function A_process_function;
AT_cpu_state A_cpu_state;
AT_route_dst A_route_dst;
AT_network_link_latency A_network_link_latency;
AT_cpu_state_file A_cpu_state_file;
AT_network_link_state_file A_network_link_state_file;
AT_network_link_bandwidth_file A_network_link_bandwidth_file;

/* XML state. */
#ifdef FLEX_DEBUG
# define ENTER(state)	debug_enter(state,#state)
# define LEAVE		debug_leave()
# define SET(state)	debug_set(state,#state)
  static void debug_enter(int, const char*);
  static void debug_leave(void);
  static void debug_set(int, const char*);
#else
# define ENTER(state)	(yy_push_state(state))
# define LEAVE		(yy_pop_state())
# define SET(state)	BEGIN(state)
#endif

/* Generic actions. */
#define SKIP	/*skip*/
#define SUCCEED	return 0

#define FAIL	return fail
static int fail(const char*, ...);

/* Text buffer stack handling. */
char bufferstack[FLEXML_BUFFERSTACKSIZE];
char* limit = bufferstack + FLEXML_BUFFERSTACKSIZE;
typedef struct BufferLast_s {
  struct BufferLast_s *old; char* saved; char new[1];
} BufferLast;
BufferLast* last = (BufferLast*)0;
char* next = bufferstack;

#define BUFFERSET(P)  (P = next)
#define BUFFERPUTC(C) (assert(next<limit), *(next++) = (C))
#define BUFFERDONE    (BUFFERPUTC('\0'))

#define BUFFERLITERAL(C,P) bufferliteral(C,&(P),yytext)
static void bufferliteral(char c, char** pp, char* text)
{
  char *s = strchr(text,c), *e = strrchr(text,c);
  assert(s <= e); BUFFERSET(*pp);
  while (++s<e) {
    if (isspace(*s)) { BUFFERPUTC(' '); while (isspace(*s)) ++s; }
    else BUFFERPUTC(*s);
  } 
  BUFFERDONE;
}

#ifdef FLEXML_HasMixed
static void pushbuffer(char* p)
{
  BufferLast* l = (BufferLast*)next;
  assert(next < limit);
  l->old = last;
  l->saved = p;
  next = l->new;
  last = l;
}

static char* popbuffer(void)
{
  BufferLast* l = last;
  assert(last != (BufferLast*)0);
  last = l->old;
  next = (char*)l;
  return l->saved;
}
#endif

/* General internal entities are `unput' back onto the input stream... */
#define ENTITYTEXT(T) \
  { char *s = (T), *e = s+strlen(s);\
    while (--e >= s) { unput(*e); }}
%}

/* Flex standard options. */
%option stack
%option noyy_top_state
%option noinput
%option noreject
%option noyymore
%option noyywrap

/* Flex user-requested options. */
%option nounput

/* XML character classes (currently restricted to ASCII). */

/* "Common syntactic structures." */
S		[ \t\n\r\f]+
s		[ \t\n\r\f]*

/* "Names and Tokens." */
NameChar	[A-Za-z0-9.:_-]
Name		[A-Za-z_:]{NameChar}*
Names 		{Name}({S}{Name})*
Nmtoken		({NameChar})+
Nmtokens 	{Nmtoken}({S}{Nmtoken})*

/* Miscellaneous. */
VersionNum	[a-zA-Z0-9_.:-]+
Eq		{s}"="{s}
Literal		\'[^'']*\'|\"[^""]*\"

/* Parser states (flex `exclusive start conditions'):
 *
 * PROLOG	the XML prolog of the document before <?xml...>
 * DOCTYPE	the XML prolog of the document after <?xml...>
 * EPILOG	after the root element
 * INCOMMENT	inside an XML comment <!--....-->
 * INPI		inside an XML PI <?...?>
 * VALUE1	inside a '...'-delimited literal
 * VALUE2	inside a "..."-delimited literal
 * CDATA	inside a <![CDATA[...]]> section.
 * ROOT_<tag>	expect root element <tag>
 * AL_<tag>	inside the attribute list for <tag>
 * IN_<tag>	inside a <tag> with element contents (ready for end tag)
 * IMPOSSIBLE	dummy to permit disabling rules; must be last
 */
%x PROLOG DOCTYPE EPILOG INCOMMENT INPI VALUE1 VALUE2 CDATA
%x ROOT_platform_description AL_platform_description S_platform_description S_platform_description_1 S_platform_description_2 E_platform_description
%x ROOT_cpu AL_cpu E_cpu
%x ROOT_network_link AL_network_link E_network_link
%x ROOT_route AL_route S_route S_route_1 S_route_2 E_route
%x ROOT_route_element AL_route_element E_route_element
%x ROOT_process AL_process S_process S_process_1 S_process_2 E_process
%x ROOT_argument AL_argument E_argument
%x IMPOSSIBLE

%{
/* State names. */
const char* *statenames=NULL;
%}

%%

 /* Bypass Flex's default INITIAL state and begin by parsing the XML prolog. */
 SET(PROLOG);
  /* FleXML_init */
  if(!statenames) statenames=calloc(IMPOSSIBLE,sizeof(char*));
  statenames[PROLOG] = NULL;
  statenames[DOCTYPE] = NULL;
  statenames[EPILOG] = NULL;
  statenames[INCOMMENT] = NULL;
  statenames[INPI] = NULL;
  statenames[VALUE1] = NULL;
  statenames[VALUE2] = NULL;
  statenames[CDATA] = NULL;
  statenames[ROOT_platform_description] = NULL;
  statenames[AL_platform_description] = NULL;
  statenames[S_platform_description] = "platform_description";
  statenames[S_platform_description_1] = "platform_description";
  statenames[S_platform_description_2] = "platform_description";
  statenames[E_platform_description] = "platform_description";
  statenames[ROOT_cpu] = NULL;
  statenames[AL_cpu] = NULL;
  statenames[E_cpu] = "cpu";
  statenames[ROOT_network_link] = NULL;
  statenames[AL_network_link] = NULL;
  statenames[E_network_link] = "network_link";
  statenames[ROOT_route] = NULL;
  statenames[AL_route] = NULL;
  statenames[S_route] = "route";
  statenames[S_route_1] = "route";
  statenames[S_route_2] = "route";
  statenames[E_route] = "route";
  statenames[ROOT_route_element] = NULL;
  statenames[AL_route_element] = NULL;
  statenames[E_route_element] = "route_element";
  statenames[ROOT_process] = NULL;
  statenames[AL_process] = NULL;
  statenames[S_process] = "process";
  statenames[S_process_1] = "process";
  statenames[S_process_2] = "process";
  statenames[E_process] = "process";
  statenames[ROOT_argument] = NULL;
  statenames[AL_argument] = NULL;
  statenames[E_argument] = "argument";

 /* COMMENTS and PIs: handled uniformly for efficiency. */

<ROOT_platform_description,AL_platform_description,S_platform_description,S_platform_description_1,S_platform_description_2,E_platform_description,ROOT_cpu,AL_cpu,E_cpu,ROOT_network_link,AL_network_link,E_network_link,ROOT_route,AL_route,S_route,S_route_1,S_route_2,E_route,ROOT_route_element,AL_route_element,E_route_element,ROOT_process,AL_process,S_process,S_process_1,S_process_2,E_process,ROOT_argument,AL_argument,E_argument,PROLOG,DOCTYPE,EPILOG>{
 "<!--" ENTER(INCOMMENT);
 "<?" ENTER(INPI);
}
<INCOMMENT>{
 "-->"		LEAVE;
 "--"		|
 .		|
 \n		SKIP;
 <<EOF>>	fail("EOF in comment.");
}
<INPI>{
 "?>"		LEAVE;
 .		|
 \n		SKIP;
 <<EOF>>	fail("EOF in PI (processing instruction).");
}

 /* SPACES: skipped uniformly */

<ROOT_platform_description,AL_platform_description,S_platform_description,S_platform_description_1,S_platform_description_2,E_platform_description,ROOT_cpu,AL_cpu,E_cpu,ROOT_network_link,AL_network_link,E_network_link,ROOT_route,AL_route,S_route,S_route_1,S_route_2,E_route,ROOT_route_element,AL_route_element,E_route_element,ROOT_process,AL_process,S_process,S_process_1,S_process_2,E_process,ROOT_argument,AL_argument,E_argument,PROLOG,DOCTYPE,EPILOG>{S} SKIP;

 /* PROLOG: determine root element and process it. */

<PROLOG>{
 "<?xml"({S}version{Eq}(\'{VersionNum}\'|\"{VersionNum}\"))?"?>" SET(DOCTYPE);
 "<?xml"[^>]*">" fail("Bad declaration %s.",yytext);
}

<PROLOG,DOCTYPE>{
 "<!DOCTYPE"{S}"argument"{S}SYSTEM{S}("'surfxml.dtd'"|"\"surfxml.dtd\""){s}">" SET(ROOT_argument);
 "<!DOCTYPE"{S}"route_element"{S}SYSTEM{S}("'surfxml.dtd'"|"\"surfxml.dtd\""){s}">" SET(ROOT_route_element);
 "<!DOCTYPE"{S}"cpu"{S}SYSTEM{S}("'surfxml.dtd'"|"\"surfxml.dtd\""){s}">" SET(ROOT_cpu);
 "<!DOCTYPE"{S}"route"{S}SYSTEM{S}("'surfxml.dtd'"|"\"surfxml.dtd\""){s}">" SET(ROOT_route);
 "<!DOCTYPE"{S}"platform_description"{S}SYSTEM{S}("'surfxml.dtd'"|"\"surfxml.dtd\""){s}">" SET(ROOT_platform_description);
 "<!DOCTYPE"{S}"network_link"{S}SYSTEM{S}("'surfxml.dtd'"|"\"surfxml.dtd\""){s}">" SET(ROOT_network_link);
 "<!DOCTYPE"{S}"process"{S}SYSTEM{S}("'surfxml.dtd'"|"\"surfxml.dtd\""){s}">" SET(ROOT_process);
 "<!"[^>-][^>]*">" fail("Bad declaration %s.",yytext);
 . 		fail("Unexpected character `%c' in prolog.", yytext[0]);
 <<EOF>> 	fail("EOF in prolog.");
}

 /* RULES DERIVED FROM DTD. */

 /* <!-- Small DTD for SURF based tools. -->  */

<ROOT_platform_description>"<platform_description"{s} {
  ENTER(AL_platform_description);
  }

<AL_platform_description>{
 ">" {
  LEAVE; STag_platform_description();pcdata = NULL; ENTER(S_platform_description);
 }
 "/>" {
  LEAVE; STag_platform_description(); pcdata = NULL; ETag_platform_description();
  switch (YY_START) {
   case ROOT_platform_description: SET(EPILOG); break;
  }
 }
 .       fail("Unexpected character `%c' in attribute list of platform_description element.", yytext[0]);
 {Name} fail("Bad attribute `%s' in `platform_description' element start tag.",yytext);
 <<EOF>> fail("EOF in attribute list of `platform_description' element.");
}

<E_platform_description,S_platform_description_2,S_platform_description>{
 "</platform_description"{s}">" {
  LEAVE;
  ETag_platform_description();
  switch (YY_START) {
   case ROOT_platform_description: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" fail("Unexpected end-tag `%s': `</platform_description>' expected.",yytext);
 .       fail("Unexpected character `%c': `</platform_description>' expected.",yytext[0]);
 <<EOF>> fail("Premature EOF: `</platform_description>' expected.");
}

<ROOT_cpu,S_platform_description_2,S_platform_description_1,S_platform_description>"<cpu"{s} {
  A_cpu_name = NULL;
  A_cpu_power = NULL;
  A_cpu_availability = "1.0";
  A_cpu_availability_file = NULL;
  A_cpu_state = A_cpu_state_ON;
  A_cpu_state_file = NULL;
  ENTER(AL_cpu);
  }

<AL_cpu>{
 "name"{Eq}\' ENTER(VALUE1); BUFFERSET(A_cpu_name);
 "name"{Eq}\" ENTER(VALUE2); BUFFERSET(A_cpu_name);

 "power"{Eq}\' ENTER(VALUE1); BUFFERSET(A_cpu_power);
 "power"{Eq}\" ENTER(VALUE2); BUFFERSET(A_cpu_power);

 "availability"{Eq}\' ENTER(VALUE1); BUFFERSET(A_cpu_availability);
 "availability"{Eq}\" ENTER(VALUE2); BUFFERSET(A_cpu_availability);

 "availability_file"{Eq}\' ENTER(VALUE1); BUFFERSET(A_cpu_availability_file);
 "availability_file"{Eq}\" ENTER(VALUE2); BUFFERSET(A_cpu_availability_file);

 "state"{Eq}"'ON'" |
 "state"{Eq}"\"ON\"" A_cpu_state = A_cpu_state_ON;
 "state"{Eq}"'OFF'" |
 "state"{Eq}"\"OFF\"" A_cpu_state = A_cpu_state_OFF;

 "state_file"{Eq}\' ENTER(VALUE1); BUFFERSET(A_cpu_state_file);
 "state_file"{Eq}\" ENTER(VALUE2); BUFFERSET(A_cpu_state_file);

 ">" {
  if (!A_cpu_name) fail("Required attribute `name' not set for `cpu' element.");
  if (!A_cpu_power) fail("Required attribute `power' not set for `cpu' element.");
  LEAVE; STag_cpu();pcdata = NULL; ENTER(E_cpu);
 }
 "/>" {
  if (!A_cpu_name) fail("Required attribute `name' not set for `cpu' element.");
  if (!A_cpu_power) fail("Required attribute `power' not set for `cpu' element.");
  LEAVE; STag_cpu(); pcdata = NULL; ETag_cpu();
  switch (YY_START) {
   case S_platform_description_2: case S_platform_description_1: case S_platform_description: SET(S_platform_description_2); break;
   case ROOT_cpu: SET(EPILOG); break;
  }
 }
 .       fail("Unexpected character `%c' in attribute list of cpu element.", yytext[0]);
 {Name} fail("Bad attribute `%s' in `cpu' element start tag.",yytext);
 <<EOF>> fail("EOF in attribute list of `cpu' element.");
}

<E_cpu>{
 "</cpu"{s}">" {
  LEAVE;
  ETag_cpu();
  switch (YY_START) {
   case S_platform_description_2: case S_platform_description_1: case S_platform_description: SET(S_platform_description_2); break;
   case ROOT_cpu: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" fail("Unexpected end-tag `%s': `</cpu>' expected.",yytext);
 .       fail("Unexpected character `%c': `</cpu>' expected.",yytext[0]);
 <<EOF>> fail("Premature EOF: `</cpu>' expected.");
}

<ROOT_network_link,S_platform_description_2,S_platform_description_1,S_platform_description>"<network_link"{s} {
  A_network_link_name = NULL;
  A_network_link_bandwidth = NULL;
  A_network_link_bandwidth_file = NULL;
  A_network_link_latency = "0.001";
  A_network_link_latency_file = NULL;
  A_network_link_state = A_network_link_state_ON;
  A_network_link_state_file = NULL;
  ENTER(AL_network_link);
  }

<AL_network_link>{
 "name"{Eq}\' ENTER(VALUE1); BUFFERSET(A_network_link_name);
 "name"{Eq}\" ENTER(VALUE2); BUFFERSET(A_network_link_name);

 "bandwidth"{Eq}\' ENTER(VALUE1); BUFFERSET(A_network_link_bandwidth);
 "bandwidth"{Eq}\" ENTER(VALUE2); BUFFERSET(A_network_link_bandwidth);

 "bandwidth_file"{Eq}\' ENTER(VALUE1); BUFFERSET(A_network_link_bandwidth_file);
 "bandwidth_file"{Eq}\" ENTER(VALUE2); BUFFERSET(A_network_link_bandwidth_file);

 "latency"{Eq}\' ENTER(VALUE1); BUFFERSET(A_network_link_latency);
 "latency"{Eq}\" ENTER(VALUE2); BUFFERSET(A_network_link_latency);

 "latency_file"{Eq}\' ENTER(VALUE1); BUFFERSET(A_network_link_latency_file);
 "latency_file"{Eq}\" ENTER(VALUE2); BUFFERSET(A_network_link_latency_file);

 "state"{Eq}"'ON'" |
 "state"{Eq}"\"ON\"" A_network_link_state = A_network_link_state_ON;
 "state"{Eq}"'OFF'" |
 "state"{Eq}"\"OFF\"" A_network_link_state = A_network_link_state_OFF;

 "state_file"{Eq}\' ENTER(VALUE1); BUFFERSET(A_network_link_state_file);
 "state_file"{Eq}\" ENTER(VALUE2); BUFFERSET(A_network_link_state_file);

 ">" {
  if (!A_network_link_name) fail("Required attribute `name' not set for `network_link' element.");
  if (!A_network_link_bandwidth) fail("Required attribute `bandwidth' not set for `network_link' element.");
  LEAVE; STag_network_link();pcdata = NULL; ENTER(E_network_link);
 }
 "/>" {
  if (!A_network_link_name) fail("Required attribute `name' not set for `network_link' element.");
  if (!A_network_link_bandwidth) fail("Required attribute `bandwidth' not set for `network_link' element.");
  LEAVE; STag_network_link(); pcdata = NULL; ETag_network_link();
  switch (YY_START) {
   case S_platform_description_2: case S_platform_description_1: case S_platform_description: SET(S_platform_description_2); break;
   case ROOT_network_link: SET(EPILOG); break;
  }
 }
 .       fail("Unexpected character `%c' in attribute list of network_link element.", yytext[0]);
 {Name} fail("Bad attribute `%s' in `network_link' element start tag.",yytext);
 <<EOF>> fail("EOF in attribute list of `network_link' element.");
}

<E_network_link>{
 "</network_link"{s}">" {
  LEAVE;
  ETag_network_link();
  switch (YY_START) {
   case S_platform_description_2: case S_platform_description_1: case S_platform_description: SET(S_platform_description_2); break;
   case ROOT_network_link: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" fail("Unexpected end-tag `%s': `</network_link>' expected.",yytext);
 .       fail("Unexpected character `%c': `</network_link>' expected.",yytext[0]);
 <<EOF>> fail("Premature EOF: `</network_link>' expected.");
}

<ROOT_route,S_platform_description_2,S_platform_description_1,S_platform_description>"<route"{s} {
  A_route_src = NULL;
  A_route_dst = NULL;
  ENTER(AL_route);
  }

<AL_route>{
 "src"{Eq}\' ENTER(VALUE1); BUFFERSET(A_route_src);
 "src"{Eq}\" ENTER(VALUE2); BUFFERSET(A_route_src);

 "dst"{Eq}\' ENTER(VALUE1); BUFFERSET(A_route_dst);
 "dst"{Eq}\" ENTER(VALUE2); BUFFERSET(A_route_dst);

 ">" {
  if (!A_route_src) fail("Required attribute `src' not set for `route' element.");
  if (!A_route_dst) fail("Required attribute `dst' not set for `route' element.");
  LEAVE; STag_route();pcdata = NULL; ENTER(S_route);
 }
 "/>" {
  if (!A_route_src) fail("Required attribute `src' not set for `route' element.");
  if (!A_route_dst) fail("Required attribute `dst' not set for `route' element.");
  LEAVE; STag_route(); pcdata = NULL; ETag_route();
  switch (YY_START) {
   case S_platform_description_2: case S_platform_description_1: case S_platform_description: SET(S_platform_description_2); break;
   case ROOT_route: SET(EPILOG); break;
  }
 }
 .       fail("Unexpected character `%c' in attribute list of route element.", yytext[0]);
 {Name} fail("Bad attribute `%s' in `route' element start tag.",yytext);
 <<EOF>> fail("EOF in attribute list of `route' element.");
}

<S_route,S_route_2,E_route>{
 "</route"{s}">" {
  LEAVE;
  ETag_route();
  switch (YY_START) {
   case S_platform_description_2: case S_platform_description_1: case S_platform_description: SET(S_platform_description_2); break;
   case ROOT_route: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" fail("Unexpected end-tag `%s': `</route>' expected.",yytext);
 .       fail("Unexpected character `%c': `</route>' expected.",yytext[0]);
 <<EOF>> fail("Premature EOF: `</route>' expected.");
}

<ROOT_route_element,S_route_1,S_route,S_route_2>"<route_element"{s} {
  A_route_element_name = NULL;
  ENTER(AL_route_element);
  }

<AL_route_element>{
 "name"{Eq}\' ENTER(VALUE1); BUFFERSET(A_route_element_name);
 "name"{Eq}\" ENTER(VALUE2); BUFFERSET(A_route_element_name);

 ">" {
  if (!A_route_element_name) fail("Required attribute `name' not set for `route_element' element.");
  LEAVE; STag_route_element();pcdata = NULL; ENTER(E_route_element);
 }
 "/>" {
  if (!A_route_element_name) fail("Required attribute `name' not set for `route_element' element.");
  LEAVE; STag_route_element(); pcdata = NULL; ETag_route_element();
  switch (YY_START) {
   case S_route_1: case S_route: case S_route_2: SET(S_route_2); break;
   case ROOT_route_element: SET(EPILOG); break;
  }
 }
 .       fail("Unexpected character `%c' in attribute list of route_element element.", yytext[0]);
 {Name} fail("Bad attribute `%s' in `route_element' element start tag.",yytext);
 <<EOF>> fail("EOF in attribute list of `route_element' element.");
}

<E_route_element>{
 "</route_element"{s}">" {
  LEAVE;
  ETag_route_element();
  switch (YY_START) {
   case S_route_1: case S_route: case S_route_2: SET(S_route_2); break;
   case ROOT_route_element: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" fail("Unexpected end-tag `%s': `</route_element>' expected.",yytext);
 .       fail("Unexpected character `%c': `</route_element>' expected.",yytext[0]);
 <<EOF>> fail("Premature EOF: `</route_element>' expected.");
}

<ROOT_process,S_platform_description_2,S_platform_description_1,S_platform_description>"<process"{s} {
  A_process_host = NULL;
  A_process_function = NULL;
  ENTER(AL_process);
  }

<AL_process>{
 "host"{Eq}\' ENTER(VALUE1); BUFFERSET(A_process_host);
 "host"{Eq}\" ENTER(VALUE2); BUFFERSET(A_process_host);

 "function"{Eq}\' ENTER(VALUE1); BUFFERSET(A_process_function);
 "function"{Eq}\" ENTER(VALUE2); BUFFERSET(A_process_function);

 ">" {
  if (!A_process_host) fail("Required attribute `host' not set for `process' element.");
  if (!A_process_function) fail("Required attribute `function' not set for `process' element.");
  LEAVE; STag_process();pcdata = NULL; ENTER(S_process);
 }
 "/>" {
  if (!A_process_host) fail("Required attribute `host' not set for `process' element.");
  if (!A_process_function) fail("Required attribute `function' not set for `process' element.");
  LEAVE; STag_process(); pcdata = NULL; ETag_process();
  switch (YY_START) {
   case S_platform_description_2: case S_platform_description_1: case S_platform_description: SET(S_platform_description_2); break;
   case ROOT_process: SET(EPILOG); break;
  }
 }
 .       fail("Unexpected character `%c' in attribute list of process element.", yytext[0]);
 {Name} fail("Bad attribute `%s' in `process' element start tag.",yytext);
 <<EOF>> fail("EOF in attribute list of `process' element.");
}

<S_process,E_process,S_process_2>{
 "</process"{s}">" {
  LEAVE;
  ETag_process();
  switch (YY_START) {
   case S_platform_description_2: case S_platform_description_1: case S_platform_description: SET(S_platform_description_2); break;
   case ROOT_process: SET(EPILOG); break;
  }
 }
 "</"{Name}{s}">" fail("Unexpected end-tag `%s': `</process>' expected.",yytext);
 .       fail("Unexpected character `%c': `</process>' expected.",yytext[0]);
 <<EOF>> fail("Premature EOF: `</process>' expected.");
}

<ROOT_argument,S_process_1,S_process,S_process_2>"<argument"{s} {
  A_argument_value = NULL;
  ENTER(AL_argument);
  }

<AL_argument>{
 "value"{Eq}\' ENTER(VALUE1); BUFFERSET(A_argument_value);
 "value"{Eq}\" ENTER(VALUE2); BUFFERSET(A_argument_value);

 ">" {
  if (!A_argument_value) fail("Required attribute `value' not set for `argument' element.");
  LEAVE; STag_argument();pcdata = NULL; ENTER(E_argument);
 }
 "/>" {
  if (!A_argument_value) fail("Required attribute `value' not set for `argument' element.");
  LEAVE; STag_argument(); pcdata = NULL; ETag_argument();
  switch (YY_START) {
   case ROOT_argument: SET(EPILOG); break;
   case S_process_1: case S_process: case S_process_2: SET(S_process_2); break;
  }
 }
 .       fail("Unexpected character `%c' in attribute list of argument element.", yytext[0]);
 {Name} fail("Bad attribute `%s' in `argument' element start tag.",yytext);
 <<EOF>> fail("EOF in attribute list of `argument' element.");
}

<E_argument>{
 "</argument"{s}">" {
  LEAVE;
  ETag_argument();
  switch (YY_START) {
   case ROOT_argument: SET(EPILOG); break;
   case S_process_1: case S_process: case S_process_2: SET(S_process_2); break;
  }
 }
 "</"{Name}{s}">" fail("Unexpected end-tag `%s': `</argument>' expected.",yytext);
 .       fail("Unexpected character `%c': `</argument>' expected.",yytext[0]);
 <<EOF>> fail("Premature EOF: `</argument>' expected.");
}

 /* EPILOG: after the root element. */

<EPILOG>{
 . 		fail("Unexpected character `%c' after document.", yytext[0]);
 <<EOF>> 	SUCCEED;
}

 /* CHARACTER DATA. */

<IMPOSSIBLE,VALUE1,VALUE2>{
 /* Non-defined standard entities... */
"&amp;"  BUFFERPUTC('&');
"&lt;"   BUFFERPUTC('<');
"&gt;"   BUFFERPUTC('>');
"&apos;" BUFFERPUTC('\'');
"&quot;" BUFFERPUTC('"');

 /* Character entities. */
 "&#"[[:digit:]]+";"	BUFFERPUTC((unsigned char)atoi(yytext+2));
 "&#x"[[:xdigit:]]+";"	BUFFERPUTC((unsigned char)strtol(yytext+3,NULL,16));
}

<IMPOSSIBLE,VALUE1,VALUE2,CDATA>{
 "\n"		|
 "\r"		|
 "\r\n"		|
 "\n\r"		BUFFERPUTC('\n');
}

<IMPOSSIBLE>{
 "<![CDATA["	ENTER(CDATA);
 "]""]>"		fail("Unexpected `]""]>' in character data.");
}

<VALUE1>{
 \'		BUFFERDONE; LEAVE;
 <<EOF>>	fail("EOF in literal (\"'\" expected).");
}

<VALUE2>{
 \"		BUFFERDONE; LEAVE;
 <<EOF>>	fail("EOF in literal (`\"' expected).");
}

<IMPOSSIBLE,VALUE1,VALUE2>{
 [^<&]		BUFFERPUTC(yytext[0]);
 [<&]		fail("Spurious `%c' in character data.",yytext[0]);
}

<CDATA>{
 "]""]>"		LEAVE;
 "]""]"		BUFFERPUTC(yytext[0]); BUFFERPUTC(yytext[1]);
 .		BUFFERPUTC(yytext[0]);
 <<EOF>>	fail("EOF in CDATA section.");
}

 /* Impossible rules to avoid warnings from flex(1). */

<INITIAL,IMPOSSIBLE>{
 .|[\n] fail("The Impossible Happened: INITIAL or IMPOSSIBLE state entered?");
}

%%

/* Element context stack lookup. */
int element_context(int i)
{
  return (0<i && i<yy_start_stack_depth
	  ? yy_start_stack[yy_start_stack_ptr - i]
	  : 0);
}

#ifdef FLEX_DEBUG
void print_yy_stack(char* fmt, ...)
{
  int i = 0; va_list ap; va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  for (i=1; i<yy_start_stack_ptr; i++)
    fprintf(stderr, "%s/", statenames[yy_start_stack[i] ]);
  fprintf(stderr,"%s\n", statenames[YY_START]);
  va_end(ap);
}

static void debug_enter(int state, const char* statename) {
  yy_push_state(state);
  if (yy_flex_debug) print_yy_stack("--ENTER(%s) : ",statename);
}

static void debug_leave(void) {
  if (yy_flex_debug) print_yy_stack("--LEAVE : ");
  yy_pop_state();
}

static void debug_set(int state, const char* statename) {
  BEGIN(state);
  if (yy_flex_debug) print_yy_stack("--SET(%s) : ",statename);
}
#endif


static int fail(const char* fmt, ...)
{
  va_list ap; va_start(ap, fmt);
#ifdef FLEXML_yylineno
  fprintf(stderr, "Invalid XML (XML input line %d, state %d): ", yylineno, YY_START);
#else
  fprintf(stderr, "Invalid XML (state %d): ",YY_START);
#endif
  vfprintf(stderr, fmt, ap);
  fprintf(stderr, "\n");
  va_end(ap);
  return 1;
}
