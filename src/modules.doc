/** 
  \defgroup SimGrid_API  API of SimGrid */

/** \defgroup XBT_API      XBT (eXtended Bundle of tools)
       \ingroup SimGrid_API
       \brief The core toolbox of SimGrid, containing usefull datatypes,
       portability support and so on.
*/
/**    \defgroup XBT_ground Grounding features of the XBT (logging and error reporting)
       \ingroup XBT_API        */
/**       \addtogroup  XBT_log
          \ingroup XBT_ground  */
/**       \addtogroup  XBT_error
          \ingroup XBT_ground  */

/**    \defgroup XBT_structs  Datatypes defined in the XBT
       \ingroup XBT_API        */
/**       \addtogroup XBT_dict
          \ingroup XBT_structs */
/**       \addtogroup XBT_dynar
          \ingroup XBT_structs */
/**       \addtogroup XBT_fifo
          \ingroup XBT_structs */
/**       \addtogroup XBT_set
          \ingroup XBT_structs */
/**        \addtogroup XBT_swag
          \ingroup XBT_structs */
/**       \addtogroup XBT_heap
          \ingroup XBT_structs */
     
/**    \defgroup XBT_port     Portability support defined in the XBT 
                              (you shouldn't use it directly) 
       \ingroup XBT_API        */
/**       \addtogroup XBT_context 
          \ingroup XBT_port    */
/**       \addtogroup XBT_sysdep
          \ingroup XBT_port    */

/** \defgroup SURF_API       SURF (simulator kernel)
    \ingroup SimGrid_API
    \brief Kernel of all the simulators used in SimGrid, and associated models.
 
      SURF provides the core functionnalities to simulate a virtual
      platform. It is very low-level and is not intended to be used as
      such but rather to serve as a basis for higher-level simulators.
      We're still working on it and the structure is a little bit
      complex. So we'll document it only when we'll be completely satisfied of 
      the way it is organized.

      It is where platform models are encoded. If you need a model that is not 
      encoded yet, please tell me (<arnaud.legrand@imag.fr>) and we'll
      see if it is feasible or not (hopefully it should be but who knows).

      Please note that as it is not really intended for public use,
      this module is only partially documented.
*/

/** \defgroup MSG_API      MSG
    \ingroup SimGrid_API
    \brief Simple programming environment 
  
      MSG was the first distributed programming environment provided within
      SimGrid. While almost realistic, it remains quite simple (simplistic?).

      You should use this model if you want to study some heuristics for a
      given problem you don't really want to implement. If you want to get a
      real implementation of your solution, have a look at the \ref GRAS_API 
      programming environment. If you want to study an existing MPI program,
      have a look at the \ref SMPI_API one. If none of those programming
      environments fits your needs, you may consider implementing your own 
      directly on top of \ref SURF_API (but you probably want to contact us
      before). 
*/
/**     \addtogroup m_datatypes_management
        \ingroup MSG_API  */
/**     \addtogroup m_process_management
        \ingroup MSG_API  */
/**     \addtogroup m_host_management
        \ingroup MSG_API  */
/**     \addtogroup m_task_management
        \ingroup MSG_API  */
/**     \addtogroup msg_gos_functions
        \ingroup MSG_API  */
/**     \addtogroup m_channel_management
        \ingroup MSG_API  */
/**     \addtogroup msg_easier_life
        \ingroup MSG_API  */
/**     \addtogroup msg_simulation
        \ingroup MSG_API  */


/** \defgroup GRAS_API      GRAS
    \ingroup SimGrid_API
    \brief Realistic programming environment (Grid Reality And Simulation)
  
    GRAS provide a complete API to implement distributed application on top
    of heterogeneous plateforms. In addition to the SimGrid implementation
    of this interface (allowing you to work on your application within the
    comfort of the simulator), an implementation suited to real platforms is
    also provided (allowing you to really use your application once you're
    done with developing it).
  
    GRAS thus constitute a complete grid application developement framework,
    encompassing both developer helping tools (the simulator and associated
    tools) and an efficient while portable execution runtime.
  
    You should use this programming environment if you want to develop real
    applications, ie if the final result of your work is a program which 
    may eventually be distributed. 
    If you just want to study some heuristics for a given problem you don't
    want to implement really (ie, if your result would be a theorem), have a
    look at the \ref MSG_API one.
    If you want to study an existing MPI program, have a look at the 
    \ref SMPI_API one. 
    If none of those programming environments fits your needs, you may
    consider implementing your own directly on top of \ref SURF_API (but you
    probably want to contact us before).
  
    The user visibile features tend to offer several kind of functionnalities:
     - <b>Communication facilities</b>: Exchanging messages between peers
     - <b>Virtualization</b>: Running both on top of the simulator and on
       top of real platforms, and portability support.
*/     
/**    \addtogroup GRAS_implem
       \ingroup GRAS_API
       
       Internals of GRAS */
/**    \addtogroup GRAS_dd
       \ingroup GRAS_API */
/**    \addtogroup GRAS_dd_implem 
       \ingroup GRAS_implem */
/**    \defgroup GRAS_sock   Sockets
       \ingroup GRAS_API
       \brief Open/close sockets, and get info on peer (Communication facility). */
/**    \defgroup GRAS_msg    Messages
       \ingroup GRAS_API
       \brief Defining messages and callbacks, and sending/receiving messages (Communication facility).
                                 */
/**    \defgroup GRAS_globals Globals
       \ingroup GRAS_API
       \brief Handling global variables so that it works on simulator (Virtualization).
     
       In GRAS, using globals is forbidden since the "processes" will
       sometimes run as a thread inside the same process (namely, in
       simulation mode). So, you have to put all globals in a structure, and
       let GRAS handle it.
       
       Use the \ref gras_userdata_new macro to create a new user data (or malloc it
       and use \ref gras_userdata_set yourself), and \ref gras_userdata_get to
       retrive a reference to it. */

/**    \defgroup GRAS_virtu Syscalls
       \ingroup GRAS_API
       \brief System call abstraction layer (Virtualization). */

/** \defgroup SMPI_API      SMPI
    \ingroup SimGrid_API
    \brief Programming environment for the simulation of MPI applications
  
    Once implemented, this programming environment will allow you to study
    within the simulator any MPI application without having to modify them
    for that. In other words, it will constitute an emulation solution for
    parallel codes.
    
    You should use this programming environment of the SimGrid suite if you
    want to study existing MPI applications.
    If you want to work on a distributed application, have a look at the 
    \ref GRAS_API environment. 
    If you want to study some heuristics for a given problem (and if your
    goal is to produce theorems, not code), have a look at the \ref MSG_API
    environment.
    If none of those programming environments fits your needs, you may
    consider implementing your own directly on top of \ref SURF_API (but you
    probably want to contact us before).
  
 */
