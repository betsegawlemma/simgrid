# Copyright (c) 2014-2016. The SimGrid Team. All rights reserved.

# This program is free software; you can redistribute it and/or modify it
# under the terms of the license (GNU LGPL) which comes with this package.

# CallType handler? name (resulttype,resultcast) (arg0name,arg0type,arg0cast) (arg1name,arg1type,arg1cast)

# CallType must be one of the three:
#
#  - Func: returning a value immediately (within the same scheduling round)
#    examples: all getters that only retrieve information with no side effect
#
#  - Proc: not returning any value (but doing so immediately) 
#    examples: all setters, *_cancel 
#
#  - Blck: Blocking call that does not return in the same scheduling round.
#    The answer requires some interaction with SURF, even if this can
#    still occure at the same timestamp under some circonstances (eg
#    if the surf_action cannot start because of resources that are down)
#    examples: things that last some time (communicate, execute, mutex_lock)
#
#    In a perfect world, these answers would also be handled by the
#    script, but we are not there yet. Instead, the answer is manually
#    generated in one of the SIMIX_post_*() functions, that are called
#    when we unpack the done and failed actions returned by surf after
#    a surf simulation round. Weird things happen if you forget to
#    answer a given simcall in there...

# Handler? is either "H" if we need to generate a handler or "-" if we should go without handlers

# I wish we could completely remove the handlers as their only use is
# to adapt the interface between the exported symbol that is visible
# by the user applications and the internal symbol that is implemented 
# by the kernel. 
# The only remaining use of that mechanism is to add the caller
# identity as a parameter of internal call, but that could be
# automatized too (eg by having a special parameter type called "self")

# Please note that in addition to completing this file with your new simcall,
# you should complete the libsmx.c file by adding the corresponding function
# (aka. stub). Anyway, if you omit to do it, the invocation of ./simcalls.py will notify you ;)
# If you want to remove an handler, it is important to remove although
# the corresponding code (simcall_HANDLER_name_of_simcall(xxx) (note that comment the code 
# is not sufficient, the python script does not check whether the code is commented or not).
# Last but not the least, you should declare the new simix call in
# ./include/simgrid/simix.h (otherwise you will get a warning at the
# compilation time)

Proc H void vm_suspend (sg_host_t ind_vm);
Proc H void vm_resume (sg_host_t ind_vm);
Proc H void vm_shutdown (sg_host_t ind_vm);
Proc H void vm_save (sg_host_t ind_vm);
Proc H void vm_restore (sg_host_t ind_vm);

Proc H void process_kill (smx_process_t process);
Proc H void process_killall (int reset_pid);
Proc - void process_cleanup (smx_process_t process);
Blck H void process_suspend (smx_process_t process);
Proc H void process_resume (smx_process_t process);
Proc H void process_set_host (smx_process_t process, sg_host_t dest);
Func - int  process_is_suspended (smx_process_t process);
Blck H int  process_join (smx_process_t process, double timeout);
Blck H int  process_sleep (double duration);

Func H smx_synchro_t execution_start (const char* name, double flops_amount, double priority, double bound, unsigned long affinity_mask);
Func - smx_synchro_t execution_parallel_start (const char* name, int host_nb, sg_host_t* host_list, double* flops_amount, double* bytes_amount, double amount, double rate);
Proc - void          execution_cancel (smx_synchro_t execution);
Proc - void          execution_set_priority (smx_synchro_t execution, double priority);
Proc - void          execution_set_bound (smx_synchro_t execution, double bound);
Proc - void          execution_set_affinity (smx_synchro_t execution, sg_host_t ws, unsigned long mask);
Blck H int           execution_wait (smx_synchro_t execution);

Proc - void          process_on_exit (smx_process_t process, int_f_pvoid_pvoid_t fun, void* data);
Proc - void          process_auto_restart_set (smx_process_t process, int auto_restart);
Func H smx_process_t process_restart (smx_process_t process);

Func - smx_mailbox_t mbox_create (const char* name);
Proc - void          mbox_set_receiver (smx_mailbox_t mbox, smx_process_t receiver);

Func H smx_synchro_t comm_iprobe (smx_mailbox_t mbox, int type, int src, int tag, simix_match_func_t match_fun, void* data);
Blck H void          comm_send (smx_process_t sender, smx_mailbox_t mbox, double task_size, double rate, void* src_buff, size_t src_buff_size, simix_match_func_t match_fun, simix_copy_data_func_t copy_data_fun, void* data, double timeout);
Func H smx_synchro_t comm_isend (smx_process_t sender, smx_mailbox_t mbox, double task_size, double rate, void* src_buff, size_t src_buff_size, simix_match_func_t match_fun, simix_clean_func_t clean_fun, simix_copy_data_func_t copy_data_fun, void* data, int detached);
Blck H void          comm_recv (smx_process_t receiver, smx_mailbox_t mbox, void* dst_buff, size_t* dst_buff_size, simix_match_func_t match_fun, simix_copy_data_func_t copy_data_fun, void* data, double timeout, double rate);
Func H smx_synchro_t comm_irecv (smx_process_t receiver, smx_mailbox_t mbox, void* dst_buff, size_t* dst_buff_size, simix_match_func_t match_fun, simix_copy_data_func_t copy_data_fun, void* data, double rate);
Blck H int           comm_waitany (xbt_dynar_t comms);
Blck H void          comm_wait (smx_synchro_t comm, double timeout);
Blck H int           comm_test (smx_synchro_t comm);
Blck H int           comm_testany (xbt_dynar_t comms);

Func H smx_mutex_t mutex_init ();
Blck H void        mutex_lock (smx_mutex_t mutex);
Func H int         mutex_trylock (smx_mutex_t mutex);
Proc H void        mutex_unlock (smx_mutex_t mutex);

Func - smx_cond_t cond_init ();
Proc - void       cond_signal (smx_cond_t cond);
Blck H void       cond_wait (smx_cond_t cond, smx_mutex_t mutex);
Blck H void       cond_wait_timeout (smx_cond_t cond, smx_mutex_t mutex, double timeout);
Proc - void       cond_broadcast (smx_cond_t cond);

Func - smx_sem_t sem_init (unsigned int capacity);
Proc H void      sem_release (smx_sem_t sem);
Func H int       sem_would_block (smx_sem_t sem);
Blck H void      sem_acquire (smx_sem_t sem);
Blck H void      sem_acquire_timeout (smx_sem_t sem, double timeout);
Func H int       sem_get_capacity (smx_sem_t sem);

Blck H sg_size_t   file_read (smx_file_t fd, sg_size_t size, sg_host_t host);
Blck H sg_size_t   file_write (smx_file_t fd, sg_size_t size, sg_host_t host);
Blck H smx_file_t  file_open (const char* fullpath, sg_host_t host);
Blck H int         file_close (smx_file_t fd, sg_host_t host);
Func - int         file_unlink (smx_file_t fd, sg_host_t host);
Func H sg_size_t   file_get_size (smx_file_t fd);
Func H sg_size_t   file_tell (smx_file_t fd);
Func H int         file_seek (smx_file_t fd, sg_offset_t offset, int origin);
Func H xbt_dynar_t file_get_info (smx_file_t fd);
Func H int         file_move (smx_file_t fd, const char* fullpath);

Func H sg_size_t  storage_get_free_size (smx_storage_t storage);
Func H sg_size_t  storage_get_used_size (smx_storage_t name);
Func - xbt_dict_t storage_get_properties (smx_storage_t storage);
Func - xbt_dict_t storage_get_content (smx_storage_t storage);

Func H xbt_dict_t asr_get_properties (const char* name);
Func H int        mc_random (int min, int max);
Proc - void       set_category (smx_synchro_t synchro, const char* category);

Proc - void run_kernel (void* code);
