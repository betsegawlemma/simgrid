/*! \page faq Frequently Asked Questions

\author Arnaud Legrand <arnaud.legrand@imag.fr>

\section faq_installation Installing the SimGrid library

Many people have been asking me questions on how to use SimGrid. Quite
often, the questions were not really about SimGrid but on the
installation process. This section is intended to help people that are
not familiar with compiling C files under UNIX. If you follow these
instructions and still have some troubles, drop me an e-mail.

\subsection faq_compiling Compiling SimGrid

Suppose you have uncompressed SimGrid in some temporary location of
your home directory (say <tt>/home/joe/tmp/simgrid-2.18.2 </tt>). The
simplest way to use SimGrid is to install it in your home
directory. Change your directory to
<tt>/home/joe/tmp/simgrid-2.18.2</tt> and type

\verbatim./configure --prefix=$HOME
make
make install
\endverbatim

If at some point, something fails, you can report me this problem but,
please, avoid sending a laconic mail like "There is a problem. Is it
normal ?". Send me the config.log file which is automatically
generated by configure. Try to capture both the standard output and
the error output of the <tt>make</tt> command. There is no way for me
to help you if you do not give me a little bit of information.

Now, the following directory should have been created : 

      \li <tt>/home/joe/doc/simgrid/html/</tt>
      \li <tt>/home/joe/lib/</tt>
      \li <tt>/home/joe/include/</tt>

SimGrid is not a binary, it is a library. Both a static and a dynamic
version are available. Here is what you can find if you try a <tt>ls
/home/joe/lib</tt>:

\verbatim libsimgrid.a  libsimgrid.la  libsimgrid.so  libsimgrid.so.0 libsimgrid.so.0.0.1
\endverbatim

Thus, there is two ways to link your program with SimGrid:
      \li Either you use the static version, e.g 
\verbatim gcc libsimgrid.a -o MainProgram MainProgram.c
\endverbatim
          In this case, all the SimGrid functions are directly
          included in <tt>MainProgram</tt> (hence a bigger binary).
      \li Either you use the dynamic version (the preferred method)
\verbatim gcc -lsimgrid -o MainProgram MainProgram.c
\endverbatim
          In this case, the SimGrid functions are not included in
          <tt>MainProgram</tt> and you need to set your environment
          variable in such a way that <tt>libsimgrid.so</tt> will be
          found at runtime. This can be done by adding the following
          line in your .bashrc (if you use bash and if you have
          installed the SimGrid libraries in your home directory):
\verbatim export LD_LIBRARY_PATH=$HOME/lib/:$LD_LIBRARY_PATH
\endverbatim

\subsection faq_setting Setting up your own code

Do not build your simulator by modifying the SimGrid examples.  Go
outside the SimGrid source tree and create your own working directory
(say <tt>/home/joe/SimGrid/MyFirstScheduler/</tt>).

Suppose your simulation has the following structure (remember it is
just an example to illustrate a possible way to compile everything;
feel free to organize it as you want).

      \li <tt>sched.h</tt>: a description of the core of the
          scheduler (i.e. which functions are can be used by the
          agents). For example we could find the following functions
          (master, forwarder, slave).

      \li <tt>sched.c</tt>: a C file including <tt>sched.h</tt> and
          implementing the core of the scheduler. Most of these
          functions use the MSG functions defined in section \ref
          msg_gos_functions.

      \li <tt>masterslave.c</tt>: a C file with the main function, i.e.
          the MSG initialization (MSG_global_init()), the platform
          creation (e.g. with MSG_create_environment()), the
          deployment phase (e.g. with MSG_function_register() and
          MSG_launch_application()) and the call to
          MSG_main()).

To compile such a program, I suggest to use the following Makefile. It
is a generic Makefile that I generally use with my students when I
teach the C language.

\verbatim
all: masterslave 
masterslave: masterslave.o sched.o

INSTALL_PATH = $$HOME
CC = gcc
PEDANTIC_PARANOID_FREAK =       -O0 -Wshadow -Wcast-align \
				-Waggregate-return -Wmissing-prototypes -Wmissing-declarations \
				-Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations \
				-Wmissing-noreturn -Wredundant-decls -Wnested-externs \
				-Wpointer-arith -Wwrite-strings -finline-functions
REASONABLY_CAREFUL_DUDE =	-Wall
NO_PRAYER_FOR_THE_WICKED =	-w -O2 
WARNINGS = 			$(REASONABLY_CAREFUL_DUDE)
CFLAGS = -g $(WARNINGS)

INCLUDES = -I$(INSTALL_PATH)/include
DEFS = -L$(INSTALL_PATH)/lib/
LDADD = -lm -lsimgrid 
LIBS = 

%: %.o
	$(CC) $(INCLUDES) $(DEFS) $(CFLAGS) $^ $(LIBS) $(LDADD) -o $@ 

%.o: %.c
	$(CC) $(INCLUDES) $(DEFS) $(CFLAGS) -c -o $@ $<

clean:
	rm -f $(BIN_FILES) *.o *~
.SUFFIXES:
.PHONY : clean

\endverbatim

The first two lines indicates what should be build when typing make
(<tt>masterslave</tt>) and of which files it is to be made of
(<tt>masterslave.o</tt> and <tt>sched.o</tt>). This makefile assumes
that you have set up correctly your <tt>LD_LIBRARY_PATH</tt> variable
(look, there is a <tt>LDADD = -lm -lsimgrid</tt>). If you prefer using
the static version, remove the <tt>-lsimgrid</tt> and add a
<tt>$(INSTALL_PATH)/lib/libsimgrid.a</tt> on the next line, right
after the <tt>LIBS = </tt>.

More generally, if you have never written a Makefile by yourself, type
in a terminal : <tt>info make</tt> and read the introduction. The
previous example should be enough for a first try but you may want to
perform some more complex compilations...

\section faq_simgrid I'm new to SimGrid. I have some questions. Where should I start ?

You are at the right place... Having a look to these <a
href="http://graal.ens-lyon.fr/~alegrand/articles/Simgrid-Introduction.pdf">slides</a>
may give you some insights on what SimGrid can help you to do and what
are its limitations. Then you definitely should read the \ref
MSG_examples.

\subsection faq_generic Building a generic simulator

Please read carefully the \ref MSG_examples. You'll find in \ref
msg_test.c a very simple consisting of a master (that owns a bunch of
tasks and distributes them) , some slaves (that process tasks whenever
they receive one) and some forwarder agents (that simply pass the
tasks they receive to some slaves).

\subsection faq_examples I want some more complex examples !

Many people have come to ask me a more complex example and each time,
they have realized afterward that the basics were in the previous three
examples. 

Of course they have often been needing more complex functions like
MSG_process_suspend(), MSG_process_resume() and
MSG_process_isSuspended() (to perform synchronization), or
MSG_task_Iprobe() and MSG_process_sleep() (to avoid blocking
receptions), or even MSG_process_create() (to design asynchronous
communications or computations). But the examples are sufficient to
start.

I know I should add some more examples, but not some more complex
ones... I should add some examples that illustrate some other
functionalities (like how to simply encode asynchronous
communications, RPC, process migrations, thread synchronization, ...)
and I will do it when I will have a little bit more time. I have tried
to document the examples so that they are understandable. I know it is
not really satisfying but it is the best I have managed to do yet.

\subsection faq_platform Building a realistic platform

I can speak more than an hour on this subject and I still do not have
the right answer, just some ideas. You can read the following <a
href="http://graal.ens-lyon.fr/~alegrand/articles/Simgrid-Introduction.pdf">slides</a>.
It may give you some hints. You can also have a look at the
<tt>tools/platform_generation/</tt> directory. There is a perl-script
I use to annotate a Tiers generated platform (may not be up-to-date
though).

\subsection faq_visualization Visualizing the schedule

It is sometime convenient to "see" how the agents are behaving. If you
like colors, you can use <tt>tools/colorize.pl</tt> as a filter to you
MSG outputs. It is intended to work with the output generated by
PRINT_MESSAGE() (a macro defined in
<tt>example/msg/messages.h</tt>). Beware, PRINT_MESSAGE() prints on
stderr. Do not forget to redirect if you want to filter (e.g. with
bash): 
\verbatim ./masterslave3 platform.txt deployment.txt 2>&1 | ../../tools/colorize.pl \endverbatim

That would be great to have something more graphical. As soon as I'll
have a little bit more time, I will write a piece of code that
generates an input to <a href="http://www-id.imag.fr/Logiciels/paje/">Paje</a>.

\subsection faq_context I have tons of process and it is limiting my simulation.

MSG can use either pthreads or the GNU context library. On most
systems, the number of pthreads is limited (especially with the
current linux pthreads) and then your simulation may be limited for a
stupid reason. If you enable the context option
(<tt>--enable-context</tt> in the <tt>./configure</tt> phase), you
will not use the pthread anymore and the context switching will be
done manually, which enables us to have as much agents as your memory
can hold and should be much faster... So think about it if your
simulation is getting really big.

Nevertheless, be aware that this code does not work on some system. It
is not very clean. As usual, as soon as I will have a little bit more
time, I will recode it in a cleaner way.

\section faq_stupid Stupid Questions

\subsection faq_GridSim Are SimGrid and GridSim the same ?

Are you kidding ? SimGrid is plain C and GridSim is written in
Java... I'm sarcastic but I'm pissed of all these poeple arguing that
their software is well-structured and higly portable thanks to Java. A
C program can also be structured in an object-oriented way and be
highly portable (just try to run Java on IRIX... ;).

According to different published papers, both SimGrid and GridSim seem
to have the same kind of goal but I have never succeeded in compiling
GridSim (but I may not be very objective since I always have troubles
when trying to run java programs) and its documentation has not
enlightened me. If you have suceeded and can tell me more about it,
please tell me.

\subsection faq_stupid_MSG What is MSG and why do you like it ?

Monosodium glutamate (MSG) is used as a flavor enhancer in a variety
of foods prepared at home, in restaurants, and by food processors. Its
use has become controversial in the past 30 years because of reports of
adverse reactions in people who've eaten foods that contain MSG. Research
on the role of glutamate--a group of chemicals that includes MSG--in the
nervous system also has raised questions about the chemical's safety.

For more information, see http://www.truthinlabeling.org/ or
http://www.msg.net/

It also stands for Meta-SimgGrid. It is a simulator written on top of
Simgrid that can be used to easily simulate many process running on a
computing platform.

I also like it because it gives flavor and it's addictive. ;)

*/