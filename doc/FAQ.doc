/*! \page faq Frequently Asked Questions

\author Arnaud Legrand <arnaud.legrand#imag.fr>

\section faq_installation Installing the SimGrid library

Many people have been asking me questions on how to use SimGrid. Quite
often, the questions were not really about SimGrid but on the
installation process. This section is intended to help people that are
not familiar with compiling C files under UNIX. If you follow these
instructions and still have some troubles, drop an e-mail to
<simgrid-user@lists.gforge.inria.fr>.

\subsection faq_compiling Compiling SimGrid

Suppose you have uncompressed SimGrid in some temporary location of
your home directory (say <tt>/home/joe/tmp/simgrid-2.18.2 </tt>). The
simplest way to use SimGrid is to install it in your home
directory. Change your directory to
<tt>/home/joe/tmp/simgrid-2.18.2</tt> and type

\verbatim./configure --prefix=$HOME
make
make install
\endverbatim

If at some point, something fails, you can report me this problem but,
please, avoid sending a laconic mail like "There is a problem. Is it
normal ?". Send me the config.log file which is automatically
generated by configure. Try to capture both the standard output and
the error output of the <tt>make</tt> command. There is no way for me
to help you if you do not give me a little bit of information.

Now, the following directory should have been created : 

      \li <tt>/home/joe/doc/simgrid/html/</tt>
      \li <tt>/home/joe/lib/</tt>
      \li <tt>/home/joe/include/</tt>

SimGrid is not a binary, it is a library. Both a static and a dynamic
version are available. Here is what you can find if you try a <tt>ls
/home/joe/lib</tt>:

\verbatim libsimgrid.a  libsimgrid.la  libsimgrid.so  libsimgrid.so.0 libsimgrid.so.0.0.1
\endverbatim

Thus, there is two ways to link your program with SimGrid:
      \li Either you use the static version, e.g 
\verbatim gcc libsimgrid.a -o MainProgram MainProgram.c
\endverbatim
          In this case, all the SimGrid functions are directly
          included in <tt>MainProgram</tt> (hence a bigger binary).
      \li Either you use the dynamic version (the preferred method)
\verbatim gcc -lsimgrid -o MainProgram MainProgram.c
\endverbatim
          In this case, the SimGrid functions are not included in
          <tt>MainProgram</tt> and you need to set your environment
          variable in such a way that <tt>libsimgrid.so</tt> will be
          found at runtime. This can be done by adding the following
          line in your .bashrc (if you use bash and if you have
          installed the SimGrid libraries in your home directory):
\verbatim export LD_LIBRARY_PATH=$HOME/lib/:$LD_LIBRARY_PATH
\endverbatim

\subsection faq_setting Setting up your own code

Do not build your simulator by modifying the SimGrid examples.  Go
outside the SimGrid source tree and create your own working directory
(say <tt>/home/joe/SimGrid/MyFirstScheduler/</tt>).

Suppose your simulation has the following structure (remember it is
just an example to illustrate a possible way to compile everything;
feel free to organize it as you want).

      \li <tt>sched.h</tt>: a description of the core of the
          scheduler (i.e. which functions are can be used by the
          agents). For example we could find the following functions
          (master, forwarder, slave).

      \li <tt>sched.c</tt>: a C file including <tt>sched.h</tt> and
          implementing the core of the scheduler. Most of these
          functions use the MSG functions defined in section \ref
          msg_gos_functions.

      \li <tt>masterslave.c</tt>: a C file with the main function, i.e.
          the MSG initialization (MSG_global_init()), the platform
          creation (e.g. with MSG_create_environment()), the
          deployment phase (e.g. with MSG_function_register() and
          MSG_launch_application()) and the call to
          MSG_main()).

To compile such a program, I suggest to use the following Makefile. It
is a generic Makefile that I generally use with my students when I
teach the C language.

\verbatim
all: masterslave 
masterslave: masterslave.o sched.o

INSTALL_PATH = $$HOME
CC = gcc
PEDANTIC_PARANOID_FREAK =       -O0 -Wshadow -Wcast-align \
				-Waggregate-return -Wmissing-prototypes -Wmissing-declarations \
				-Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations \
				-Wmissing-noreturn -Wredundant-decls -Wnested-externs \
				-Wpointer-arith -Wwrite-strings -finline-functions
REASONABLY_CAREFUL_DUDE =	-Wall
NO_PRAYER_FOR_THE_WICKED =	-w -O2 
WARNINGS = 			$(REASONABLY_CAREFUL_DUDE)
CFLAGS = -g $(WARNINGS)

INCLUDES = -I$(INSTALL_PATH)/include
DEFS = -L$(INSTALL_PATH)/lib/
LDADD = -lm -lsimgrid 
LIBS = 

%: %.o
	$(CC) $(INCLUDES) $(DEFS) $(CFLAGS) $^ $(LIBS) $(LDADD) -o $@ 

%.o: %.c
	$(CC) $(INCLUDES) $(DEFS) $(CFLAGS) -c -o $@ $<

clean:
	rm -f $(BIN_FILES) *.o *~
.SUFFIXES:
.PHONY : clean

\endverbatim

The first two lines indicates what should be build when typing make
(<tt>masterslave</tt>) and of which files it is to be made of
(<tt>masterslave.o</tt> and <tt>sched.o</tt>). This makefile assumes
that you have set up correctly your <tt>LD_LIBRARY_PATH</tt> variable
(look, there is a <tt>LDADD = -lm -lsimgrid</tt>). If you prefer using
the static version, remove the <tt>-lsimgrid</tt> and add a
<tt>$(INSTALL_PATH)/lib/libsimgrid.a</tt> on the next line, right
after the <tt>LIBS = </tt>.

More generally, if you have never written a Makefile by yourself, type
in a terminal : <tt>info make</tt> and read the introduction. The
previous example should be enough for a first try but you may want to
perform some more complex compilations...

\section faq_simgrid I'm new to SimGrid. I have some questions. Where should I start ?

You are at the right place... Having a look to these <a
href="http://graal.ens-lyon.fr/~alegrand/articles/Simgrid-Introduction.pdf">slides</a>
may give you some insights on what SimGrid can help you to do and what
are its limitations. Then you definitely should read the \ref
MSG_examples. There is also a mailing list: <simgrid-user#lists.gforge.inria.fr>.

\subsection faq_generic Building a generic simulator

Please read carefully the \ref MSG_examples. You'll find in \ref
MSG_ex_master_slave a very simple consisting of a master (that owns a bunch of
tasks and distributes them) , some slaves (that process tasks whenever
they receive one) and some forwarder agents (that simply pass the
tasks they receive to some slaves).

\subsection faq_examples I want some more complex examples !

Many people have come to ask me a more complex example and each time,
they have realized afterward that the basics were in the previous three
examples. 

Of course they have often been needing more complex functions like
MSG_process_suspend(), MSG_process_resume() and
MSG_process_isSuspended() (to perform synchronization), or
MSG_task_Iprobe() and MSG_process_sleep() (to avoid blocking
receptions), or even MSG_process_create() (to design asynchronous
communications or computations). But the examples are sufficient to
start.

I know I should add some more examples, but not some more complex
ones... I should add some examples that illustrate some other
functionalities (like how to simply encode asynchronous
communications, RPC, process migrations, thread synchronization, ...)
and I will do it when I will have a little bit more time. I have tried
to document the examples so that they are understandable. I know it is
not really satisfying but it is the best I have managed to do yet.

\subsection faq_platform Building a realistic platform

I can speak more than an hour on this subject and I still do not have
the right answer, just some ideas. You can read the following <a
href="http://graal.ens-lyon.fr/~alegrand/articles/Simgrid-Introduction.pdf">slides</a>.
It may give you some hints. You can also have a look at the
<tt>tools/platform_generation/</tt> directory. There is a perl-script
I use to annotate a Tiers generated platform (may not be up-to-date
though).

\subsection faq_visualization Visualizing the schedule

It is sometime convenient to "see" how the agents are behaving. If you
like colors, you can use <tt>tools/MSG_visualization/colorize.pl </tt>
as a filter to your MSG outputs. It works directly with INFO. Beware,
INFO() prints on stderr. Do not forget to redirect if you want to
filter (e.g. with bash): 
\verbatim 
./msg_test small_platform.xml small_deployment.xml 2>&1 | ../../tools/MSG_visualization/colorize.pl
\endverbatim

We also have a more graphical output. Have a look at MSG_paje_output(). It 
generates an input to <a href="http://www-id.imag.fr/Logiciels/paje/">Paje</a>.
<center>
\htmlonly
 <a href="Paje_MSG_screenshot.jpg"><img src="Paje_MSG_screenshot_thn.jpg"></a>
\endhtmlonly
</center>

\subsection faq_context I have tons of process and it is limiting my simulation.

MSG can use either pthreads or the GNU context library. On most
systems, the number of pthreads is limited (especially with the
current linux pthreads) and then your simulation may be limited for a
stupid reason. If you enable the context option
(<tt>--enable-context</tt> in the <tt>./configure</tt> phase), you
will not use the pthread anymore and the context switching will be
done manually, which enables us to have as much agents as your memory
can hold and should be much faster... So think about it if your
simulation is getting really big.

Nevertheless, be aware that this code does not work on some system. It
is not very clean. As usual, as soon as I will have a little bit more
time, I will recode it in a cleaner way.

\section faq_SG Where has SG disappeared ?!?

OK, it's time to explain what's happening to the SimGrid project. Let's
start with a little bit of history.

* Historically, SimGrid was a low-level toolkit for scheduling with
classical models such as DAGs. That was SimGrid v.1.* aka SG, written by
Henri Casanova. I had been using it in its earliest versions during an
internship at UCSD.

Then we have realized that encoding distributed algorithm in SG was a
real pain.

* So we have built MSG on top of SG and have released SimGrid v.2.*. MSG
offered a very basic API to encode a distributed application easily.
However encoding MSG on top of SG was not really convenient and did not
use the DAG part since the control of the task synchronization was done
on top of MSG and no more in SG. We have been playing a little bit with
MSG. We have realized that:

   \li 1) the platform modeling was quite flexible and could be "almost"
       automated (e.g. using random generator and post-annotations);

   \li 2) SG was the bottleneck because of the way we were using
       it. We needed to simulate concurrent transfers, complex load
       sharing mechanisms. Many optimizations (e.g. trace integration)
       were totally inefficient when combined with MSG and made extending SG
       to implement new sharing policies, parallel tasks models, or failures
       (many people were asking for these kind of features) a real pain;

   \li 3) the application modeling was not really easy. Even though the
       application modeling depends on people's applications, we thought
       we could improve things here. One of our target here was realistic
distributed applications ranging from computer sensor networks like
the NWS to peer-to-peer applications;

* So we have been planning mainly two things for SimGrid 3:

   \li 1) I have proposed to get rid of SG and to re-implement a new kernel
       that would be faster and more flexible. That is what I did in the
end of 2004: SURF. SURF is based on a fast max-min linear solver
using O(1) data-structures. I have quickly replaced SG by SURF in
MSG and the result has been that on the MSG example, the new
version was more than 10 times faster while we had gain a lot of
flexibility. I think I could still easily make MSG faster but I
have to work on MSG now (e.g. using some of the O(1)
data-structures I've been using to build SURF) since it has become
the bottleneck. Some MSG functions have been removed from the API
but they were mainly intended to build the platform by hand (they
had appeared in the earliest versions of MSG) and were therefore
not useful anymore since we are providing a complete mechanism to
automatically build the platform and deploy the agents on it.;

   \li 2) GRAS is a new project Martin and I have come up with. The idea is
to have a programming environment that let you program real
distributed applications while letting you the ability to run it in
the simulator without having to change the slightest line of your
code. From the simulation point of view, GRAS performs the
application modeling automatically... Up until now, GRAS works on
top MSG for historical reasons but I'm going to make it work
directly on top of SURF so that it can use all the flex and the
speed provided by SURF.

Those two things are working, but we want to make everything as clean as
possible before releasing SimGrid v.3.

So what about those nice DAGs we used to have in SimGrid v.1. ? They're not
anymore in SimGrid v.3. Let me recall you the way SimGrid 3 is organized:

\verbatim
________________
|   User code  |
|______________|
| | MSG | GRAS |
| -------------|
| |   SURF     |
| -------------|
|     XBT      |
----------------
\endverbatim

XBT is our tool box and now, you should have an idea of what the other ones
are. As you can see, the primitive SG is not here anymore. However it could
still be brought back if people really need it. Here is how it would fit.

\verbatim
______________________
|    User code       |
|____________________|
| | MSG | GRAS | SG  |
| -------------------|
| |      SURF        |
| -------------------|
|        XBT         |
----------------------
\endverbatim

Re-implementing SG on top of SURF is really straightforward (it only
requires a little bit of time that I really don't have right now)
since the only thing that lacks to SURF is the DAG part. But adding it
to SURF would slow it down and therefore slow MSG and GRAS which is
not a good thing.  However it is really not on the top of our TODO
list because we have to work on GRAS, and its MPI counterpart, and a
parallel task model, and ... Anyway, we finally have migrated our CVS
to gforge so people that are interested by helping on this part will
have the possibility to do it.

\subsection But I wanted to implement a distributed dynamic scheduler of DAGs... How can I do that it SG is not available anymore in the next versions ?

Distributed is somehow "contagious". If you start making distributed
decisions, there is no way to handle DAGs directly anymore (unless I am
missing something). You have to encode your DAGs in term of communicating
process to make the whole scheduling process distributed. Believe me, it is
worth the effort since you'll then be able to try your algorithms in a very
wide variety of conditions.

If you decide that the distributed part is not that much important and that
DAG is really the level of abstraction you want to work with (but it
prevents you from having "realistic" platform modeling), then you should
keep using the 2.18.5 versions until somebody has ported SG on top of SURF.
Note however that SURF will be slower than the old SG to handle traces with
a lots of variations (there is no trace integration anymore).

*/
