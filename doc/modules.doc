/** 
  \defgroup SimGrid_API  API of SimGrid */

/** \defgroup XBT_API      XBT
       \ingroup SimGrid_API
       \brief The core toolbox of SimGrid, containing usefull datatypes,
       portability support and so on.
*/
/**    \defgroup XBT_ground Grounding features of the XBT (logging and error reporting)
       \ingroup XBT_API        */
       /** \addtogroup  XBT_log
           \ingroup XBT_ground  */
	   /** \defgroup XBT_log_cats Existing log categories
	       \ingroup XBT_log
	       \brief (automatically extracted) 
	       
	       This is the list of all existing log categories in SimGrid.
               This list was automatically extracted from the source code by
               the src/xbt_log_extract_hierarchy utility.
	       
               You can thus be certain that it is uptodate, but it may somehow
               lack a final manual touch.
	       Anyway, nothing's perfect ;)
	       */
       /** \addtogroup  XBT_error
           \ingroup XBT_ground  */

/**    \defgroup XBT_structs  Datatypes defined in the XBT
       \ingroup XBT_API        */
/**       \addtogroup XBT_dict
          \ingroup XBT_structs */
/**       \addtogroup XBT_dynar
          \ingroup XBT_structs */
/**       \addtogroup XBT_fifo
          \ingroup XBT_structs */
/**       \addtogroup XBT_set
          \ingroup XBT_structs */
/**        \addtogroup XBT_swag
          \ingroup XBT_structs */
/**       \addtogroup XBT_heap
          \ingroup XBT_structs */
     
/**    \defgroup XBT_port     Portability support defined in the XBT 
                              (you shouldn't use it directly) 
       \ingroup XBT_API        */
/**       \addtogroup XBT_context 
          \ingroup XBT_port    */
/**       \addtogroup XBT_sysdep
          \ingroup XBT_port    */

/** \defgroup SURF_API       SURF
    \ingroup SimGrid_API
    \brief Kernel of all the simulators used in SimGrid, and associated models.
 
      SURF provides the core functionnalities to simulate a virtual
      platform. It is very low-level and is not intended to be used as
      such but rather to serve as a basis for higher-level simulators.
      We're still working on it and the structure is a little bit
      complex. So we'll document it only when we'll be completely satisfied of 
      the way it is organized.

      It is where platform models are encoded. If you need a model that is not 
      encoded yet, please tell me (<arnaud.legrand@imag.fr>) and we'll
      see if it is feasible or not (hopefully it should be but who knows).

      Please note that as it is not really intended for public use,
      this module is only partially documented.
*/

/** \defgroup MSG_API      MSG
    \ingroup SimGrid_API
    \brief Simple programming environment 
  
      MSG was the first distributed programming environment provided within
      SimGrid. While almost realistic, it remains quite simple (simplistic?).

      \section MSG_who Who should use this (and who shouldn't)
      
      You should use this model if you want to study some heuristics for a
      given problem you don't really want to implement. If you want to get a
      real implementation of your solution, have a look at the \ref GRAS_API 
      programming environment. If you want to study an existing MPI program,
      have a look at the \ref SMPI_API one. If none of those programming
      environments fits your needs, you may consider implementing your own 
      directly on top of \ref SURF_API (but you probably want to contact us
      before). 
*/
/**     \addtogroup m_datatypes_management
        \ingroup MSG_API  */
/**     \addtogroup m_process_management
        \ingroup MSG_API  */
/**     \addtogroup m_host_management
        \ingroup MSG_API  */
/**     \addtogroup m_task_management
        \ingroup MSG_API  */
/**     \addtogroup msg_gos_functions
        \ingroup MSG_API  */
/**     \addtogroup m_channel_management
        \ingroup MSG_API  */
/**     \addtogroup msg_easier_life
        \ingroup MSG_API  */
/**     \addtogroup msg_simulation
        \ingroup MSG_API  */


/** \defgroup GRAS_API      GRAS
    \ingroup SimGrid_API
    \brief Realistic programming environment (Grid Reality And Simulation)
  
    GRAS provide a complete API to implement distributed application on top
    of heterogeneous plateforms. In addition to the SimGrid implementation
    of this interface (allowing you to work on your application within the
    comfort of the simulator), an implementation suited to real platforms is
    also provided (allowing you to really use your application once you're
    done with developing it).
  
    GRAS thus constitute a complete grid application developement framework,
    encompassing both developer helping tools (the simulator and associated
    tools) and an efficient while portable execution runtime.
  
    \section GRAS_who Who should use this (and who shouldn't)
    
    You should use this programming environment if you want to develop real
    applications, ie if the final result of your work is a program which 
    may eventually be distributed. 
    If you just want to study some heuristics for a given problem you don't
    want to implement really (ie, if your result would be a theorem), have a
    look at the \ref MSG_API one.
    If you want to study an existing MPI program, have a look at the 
    \ref SMPI_API one. 
    If none of those programming environments fits your needs, you may
    consider implementing your own directly on top of \ref SURF_API (but you
    probably want to contact us before).
*/

/** \defgroup SMPI_API      SMPI
    \ingroup SimGrid_API
    \brief Programming environment for the simulation of MPI applications
  
    Once implemented, this programming environment will allow you to study
    within the simulator any MPI application without having to modify them
    for that. In other words, it will constitute an emulation solution for
    parallel codes.
    
    \section SMPI_who Who should use this (and who shouldn't)
    
    You should use this programming environment of the SimGrid suite if you
    want to study existing MPI applications.
    If you want to work on a distributed application, have a look at the 
    \ref GRAS_API environment. 
    If you want to study some heuristics for a given problem (and if your
    goal is to produce theorems, not code), have a look at the \ref MSG_API
    environment.
    If none of those programming environments fits your needs, you may
    consider implementing your own directly on top of \ref SURF_API (but you
    probably want to contact us before).
  
 */
