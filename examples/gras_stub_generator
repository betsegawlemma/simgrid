#! /usr/bin/perl

# gras_stub_generator - creates the main() to use a GRAS program

# Authors: Martin Quinson
# Copyright (C) 2003 the OURAGAN project.
  
# This program is free software; you can redistribute it and/or modify it
# under the terms of the license (GNU LGPL) which comes with this package.
  
use strict;
eval qq{
  use warnings;
}; # warnings not defined in 5.00503/sun4-solaris

sub usage {
    my ($msg)=@_;
    fail ($msg? "gras_stub_generator: $msg\n":"").
	 "gras_stub_generator: USAGE\n".
	 "  gras_stub_generator project_name deployment_file\n"
}

my ($project,$deploy_file)=@ARGV;

$project && $deploy_file || usage();

my (%process);

open (DEPLOY, $deploy_file) || usage("Cannot open $deploy_file: $!");
my $linenum=0;
while (<DEPLOY>) {
    $linenum++;
    /^\W*\w*\W*(\w*)/ || usage("$deploy_file:$linenum: Parse error");
    $process{$1}=1;
}

my $warn="/***********\n * DO NOT EDIT! THIS FILE WERE AUTOMATICALLY GENERATED FROM $deploy_file BY gras_stub_generator\n ***********/\n";

#####
# Generate the file for the simulator
#####

open (OUT,">_${project}_simulator.c") || die "Cannot open _${project}_simulator,c: $!";
print OUT <<EOF
$warn

#include <stdlib.h>
#include <stdio.h>
#include "msg/msg.h"
#include <gras.h>

char *gras_log=NULL;
    
EOF
 ;
foreach (keys %process) { print OUT "int $_(int argc,char *argv[]);\n";        }
print OUT "\n";
foreach (keys %process) { print OUT "int launch_$_(int argc,char *argv[]);\n"; }
print OUT "\n$warn\n";

foreach (keys %process) {
    print OUT<<EOF
int launch_$_(int argc, char **argv) {
  char **myargv=argv;
  int myargc=argc;
  int i;
  int retcode;
    
  if (gras_log) {
    myargv=malloc((argc+1) * sizeof(char**));
    for (i=0; i<argc; i++)
      myargv[i] = argv[i];
    myargv[myargc++] = gras_log;
  }
  retcode = $_(myargc,myargv);
  if (myargv != argv)
    free(myargv);
  return retcode;
}

EOF
    ;
}
print OUT "\n$warn\n";

print OUT <<EOF
int main (int argc,char *argv[]) {
  int i,j;

  /* Save the gras-log argument of real command line to pass it to all processes */
  for (i=1; i<argc; i++) {
    if (!strncmp(argv[i],"--gras-log=",strlen("--gras-log="))) {
      if (gras_log) {
	 char *tmp=malloc(strlen(gras_log)+strlen(argv[i])+2);
	 sprintf(tmp,"%s %s",gras_log, argv[i]);
	 free(gras_log);
	 gras_log=tmp;
      } else {
         gras_log = strdup(argv[i]);
      }
      for (j=i+1; j<argc; j++) {
	argv[j-1] = argv[j];
      } 
      argv[j-1] = NULL;
      argc--;
      i--; /* compensate effect of next loop incrementation */
    }
  }

  if (argc != 3) {
    fprintf(stderr, "Usage: %s platform_file application_description.txt [--gras-log=...]\\n",argv[0]);
    exit(1);
  }

  /*  Simulation setup */
  MSG_global_init();
  MSG_set_verbosity(MSG_SILENT);
  MSG_set_channel_number(10); // GRAS_MAX_CHANNEL hardcoded since Alvin killed its definition
  MSG_create_environment(argv[1]);

  /*  Application deployment */
EOF
;
foreach (keys %process) {
    print OUT "  MSG_function_register(\"$_\", launch_$_);\n";
}
print OUT <<EOF

  MSG_launch_application(argv[2]);

  /*  Run the simulation */
  MSG_main();

  /* cleanup the place */
  MSG_clean();
  if (gras_log)
    free(gras_log);
  return 0;
}
$warn
EOF
    ;
close OUT || die "Cannot write _${project}_simulator,c: $!";

#####
# Generate the files for the real life
#####
foreach my $pname (keys %process) {
    open (OUT,">_${project}_$pname.c") || die "Cannot open _${project}_$pname,c: $!";
    print OUT <<EOF
$warn
#include <stdio.h>
#include <signal.h>
#include <gras.h>

/* user code */
int $pname(int argc, char *argv[]);

$warn

int main(int argc, char *argv[]){
  int errcode;

  errcode=$pname(argc,argv);
 
  return errcode;
}

$warn
EOF
;
    close OUT || die "Cannot write _${project}_$pname,c: $!";
}

#####
# Outputs the Makefile.am snippet
#####

print ">>> Files for project '$project' successfully generated.\n";
print ">>> Add (and edit) the following to you Makefile.am:\n\n";

print "# AUTOMAKE variable definition\n";
print "INCLUDES= \@CFLAGS_GRAS\@ \@CFLAGS_XML\@ \@CFLAGS_SimGrid\@\n\n";
print "PROGRAMS=${project}_simulator ";

foreach (keys %process) {
    print "${project}_$_ ";
}
print "\n\n${project}_simulator_SOURCES=\t_${project}_simulator.c $project.c\n";
foreach (keys %process) {
    print "${project}_${_}_SOURCES=\t_${project}_${_}.c $project.c\n";
}

print "\n\n${project}_simulator_LDADD=\tpath/to/libgrassg.a \@LIBS_SimGrid\@ \@LIBS_XML\@\n";
foreach (keys %process) {
    print "${project}_${_}_LDADD=\tpath/to/libgrasrl.a\n";
}

print "\n# cleanup temps\n";
print "CLEANFILES= _${project}_simulator.c ";
foreach (keys %process) {
    print "_${project}_$_.c ";
}
print "\n";

print "\n# generate temps\n";
# A rule to generate the source file each time the deployment file changes
foreach (keys %process) {
    print "_${project}_$_.c ";
}
print "_${project}_simulator.c: $deploy_file\n";
print "\tgras_stub_generator $project $deploy_file >/dev/null\n";


print "\n>>> Bye.\n"
